# E2 権限評価・共有（Sharing）詳細設計 v1

## 0. 用語とスコープ

* **Object Permission**：Create/Read/Edit/Delete/ViewAll/ModifyAll など（オブジェクト単位）
* **Field Permission**：Readable/Editable（項目単位）
* **Record Access（Sharing）**：そのレコードに対する Read/Write（行単位）
* **OWD**：Organization-Wide Default（全社既定の公開範囲：Private / Public Read Only / Public Read-Write / Controlled by Parent）
* **Share Row**：`object_shares` の1行（subjectに対するアクセス付与）

本設計は **Sales Cloud相当**の一般的な共有モデルを実装する前提で、特に以下を対象にします：

* Owner-based sharing（所有者）
* Role Hierarchy（上位ロール）
* Public Group / Queue
* Sharing Rules（Owner-based / Criteria-based）
* Manual Share
* Team（Account Team / Opportunity Team 等）
* Territory（Enterprise Territory Management相当）
* Implicit Sharing（親子暗黙共有：Controlled by Parent 等）
* Approval Lock（承認中ロック）

---

## 1. データモデル（権限評価に必要な入力）

### 1.1 権限（設定側：Metadata/Admin 正本）

* `profiles`
* `permission_sets`
* `permission_set_assignments`（User↔PermissionSet）
* `object_permissions`（subject=Profile/PermissionSet × objectName）

  * flags: `read, create, edit, delete, view_all, modify_all`
* `field_permissions`（subject=Profile/PermissionSet × objectName × fieldName）

  * flags: `readable, editable`
* `roles`（階層）
* `groups` / `group_members`（type=user/role…）
* `territories` / `user_territory_assignments` / `account_territory_assignments`
* `owd_settings`（objectName → OWD）

### 1.2 共有（Sharing Service 正本：Shares DB）

* `object_shares(tenant_id, object_name, record_id, subject_type, subject_id, access_level, row_cause, source_rule_id, ...)`
* `share_model_versions`（現在有効なバージョン）
* （任意）`role_closure` / `territory_closure`（木の高速解決用）

### 1.3 レコード（Core DB）

* 各オブジェクト의 `owner_id`
* 親子関係（例：Contact.account_id、Opportunity.account_id 等）
* Team（例：`opportunity_team_members`、`account_team_members`）※Core DBでもShares DBでも可（生成するならSharesに寄せる）

---

## 2. Coreに実装する“評価器”の責務

Coreに以下の2つの評価器を置きます。

### 2.1 EffectivePermissionResolver（権限展開）

入力：`userId`
出力：

* `ObjectPerm[objectName] = {C,R,U,D,ViewAll,ModifyAll}`
* `FieldPerm[objectName][fieldName] = {readable, editable}`
* `SubjectSet`（共有判定に使う「主体集合」）

  * `User(userId)`
  * `Roles(userRoleId + ancestors)`（上位ロール含む）
  * `Groups(user belongs)`（ユーザ/ロール経由で所属）
  * `Territories(user assigned + ancestors)`（必要なら）
  * `Special`（Admin相当など）

キャッシュ：Redis等に **ユーザ単位**で保持（`PermissionChanged` で失効）

### 2.2 RecordAccessEvaluator（行アクセス）

入力：`userContext（上の出力） + objectName + recordId + action(Read/Write/Delete/Share)`
出力：`ALLOW/DENY` + 理由（監査・デバッグ用）

---

## 3. 評価アルゴリズム（全体フロー）

評価は必ずこの順で短絡します（上ほど強い）。

### 3.1 事前：承認ロック（Approval Lock）

* ApprovalServiceから `LockState` を参照（キャッシュ可）
* **Write系（Edit/Delete/OwnerChange/Price等）**はロック条件に当たれば拒否

  * 例：`Edit` は `lockedFields` を含む変更がある場合拒否
  * Delete/OwnerChange は原則拒否（運用で緩和可）

### 3.2 Object Permission（オブジェクト権限）

* まず `ObjectPerm` で action が可能か判定

  * Readなし → 以降は全拒否（404扱い）
  * Editなし → 共有でWriteが付いても Edit不可（Salesforce互換の考え方に寄せる）
* `ViewAll` / `ModifyAll` は **レコード共有を短絡**する（後述）

### 3.3 Field Permission（項目権限）

* 取得：Readableでないフィールドは返さない
* 更新：Editableでないフィールドが含まれていれば 422（またはそのフィールドだけ無視は不可。標準は拒否）

### 3.4 Record Access（共有）

* `ViewAll`（Read）/`ModifyAll`（Write）を持つ場合：**共有判定スキップ**
* それ以外は OWD / Owner / Role / Territory / Team / SharingRules / ManualShare / Implicit を統合評価

---

## 4. 決定表（Record Read / Write）

### 4.1 Read（レコード閲覧）決定表

前提：Object Read はOK

| 優先 | 条件                                             | 結果      | 典型          |
| -: | ---------------------------------------------- | ------- | ----------- |
|  1 | ObjectPerm.ViewAll = true                      | Read許可  | 管理者/監査      |
|  2 | レコード所有者 = userId                               | Read許可  | Owner       |
|  3 | OWD = Public Read-Write または Public Read Only   | Read許可  | 全社公開        |
|  4 | 役割階層：ownerRole が userRole の配下（userが上位）         | Read許可  | 上長閲覧        |
|  5 | Territory：同一/上位テリトリ経由で付与                       | Read許可  | 担当領域        |
|  6 | Team：TeamMemberとして Read/Write 権限               | Read許可  | 商談/取引先チーム   |
|  7 | object_shares に subject一致で access_level ≥ Read | Read許可  | 共有ルール/手動共有等 |
|  8 | Implicit：Controlled by Parent 等で親が読める          | Read許可  | Contact等    |
|  9 | 上記いずれも満たさない                                    | 拒否（404） | Private     |

> **注意**：Implicit（親子暗黙共有）は、設計上「sharesに展開してもよい」です。
> 展開するなら 8 を 7 に吸収できます（運用・性能で選択）。

### 4.2 Write（レコード編集）決定表

前提：Object Edit はOK（Editが無いなら共有でWriteが付いても拒否）

| 優先 | 条件                                                  | 結果            |
| -: | --------------------------------------------------- | ------------- |
|  1 | ObjectPerm.ModifyAll = true                         | Write許可       |
|  2 | レコード所有者 = userId かつ（OWD/設定でOwner編集可）                | Write許可       |
|  3 | OWD = Public Read-Write                             | Write許可       |
|  4 | 役割階層で上位かつ（GrantAccessUsingHierarchies=true のオブジェクト） | Write許可       |
|  5 | Territory/Team で Write 付与                           | Write許可       |
|  6 | object_shares に subject一致で access_level = Write     | Write許可       |
|  7 | Implicitで親がWrite可能（Controlled by Parent）            | Write許可       |
|  8 | 上記いずれも満たさない                                         | 拒否（403/404方針） |

---

## 5. OWDと「Grant Access Using Hierarchies」

### 5.1 OWDの種類（v1）

* `Private`
* `PublicReadOnly`
* `PublicReadWrite`
* `ControlledByParent`（子が親に従う）

### 5.2 GrantAccessUsingHierarchies（GAUH）

Salesforce同様、オブジェクトにより「上位ロールが自動でアクセスできる」かが異なるため、以下を設定化します。

* `object_access_settings(objectName, grant_access_using_hierarchies boolean)`

  * 例：Opportunity/Account は true になりがち
  * 例：Activity は運用で false にすることもある

評価は 4.1/4.2 の「役割階層」ステップに GAUH を掛けます。

---

## 6. object_shares の“主体一致”定義（重要）

### 6.1 SubjectSet（ユーザの主体集合）

`EffectivePermissionResolver` が以下を返す：

* `User:{userId}`
* `Role:{userRoleId}` + `RoleAncestors:{...}`
* `Group:{groupIds...}`（user直＋role経由）
* `Territory:{territoryIds...}` + ancestors（採用する場合）
* （任意）`Queue:{queueIds...}`

### 6.2 share一致条件

`object_shares` の行が以下のいずれかに一致すれば付与：

* `(subject_type='User' and subject_id=userId)`
* `(subject_type='Role' and subject_id in RoleSet)`
* `(subject_type='Group' and subject_id in GroupSet)`
* `(subject_type='Territory' and subject_id in TerritorySet)`

> ここがパフォーマンスの肝なので、Shares DB側に
> `idx_share_lookup_subject(tenant_id, object_name, subject_type, subject_id)` が必須（前に定義済み）

---

## 7. Implicit Sharing（親子暗黙共有）の扱い（v1方針）

### v1ベスト（実装を簡単にし、漏洩を減らす）

* `ControlledByParent` の子は **Coreが親アクセスを再帰評価**して決める

  * 子を返すとき：親が読めるなら子も読める
  * Writeも同様
* ただしリスト性能が問題になったら、Sharing Serviceで **子へのshares展開**を追加（v2）

対象例（要件に応じて増減）：

* Contact → Account
* OpportunityLineItem → Opportunity
* QuoteLineItem → Quote
* OrderItem → Order
* ContentDocumentLink → LinkedEntity（多態なので注意）

---

## 8. Approval Lock（承認中の編集制限）詳細

### 8.1 ロック判定API（Coreが呼ぶPort）

`ApprovalStateReader.getLockState(tenantId, objectName, recordId) -> { isLocked, lockedFields[], lockLevel }`

### 8.2 書き込み時の判定

* `isLocked=true` の場合：

  * **Edit**：更新対象フィールドが `lockedFields` に含まれる → 拒否（422/403のどちらか、v1は422推奨）
  * **OwnerChange/Delete**：原則拒否（403）
* 例外（運用で許可するなら）：

  * ModifyAll持ちはロックを無視できる、等の“管理者例外”を設定化

---

## 9. API実装での適用点（漏洩を防ぐ実装ルール）

### 9.1 GetById

1. Object Read チェック（NGなら404）
2. Record Read チェック（NGなら404）
3. Field Readable マスクして返す

### 9.2 Query/List

* 「見えるレコードだけ返す」を守るため、v1は以下のどちらかに固定：

**方式A（推奨 / 安全）**：Accessible IDs を先に絞る

* shares/owd/owner等で `accessible_record_ids` を作る（SQL）→ そのID集合で本体を取得

**方式B（高速）**：本体クエリにアクセス条件をJOIN/EXISTSで埋め込む

* ただし複雑になりやすい。まずはAで固める

### 9.3 Search/Reports

* Search/Reportsは候補IDを返すだけに寄せ、
* 最終の明細取得は必ず Core Query を通して再評価（安全弁）

---

## 10. SQL評価の実装パターン（v1推奨）

### 10.1 Read可否（単一レコード）のSQL（概念）

* まず owner / owd public を短絡
* 次に shares で subject一致をEXISTS

概念：

* `is_owner OR owd_public OR exists(share_row matching subjectset) OR (gauh AND role_hierarchy)` …

### 10.2 List（Opportunityの例：My pipeline）

概念手順：

1. `candidate_ids =`

   * owner_id=user OR share rows match OR (owd public) OR (gauh via role) OR (territory/team)
2. `SELECT * FROM opportunities WHERE id in candidate_ids AND filters...`

> この “candidate_ids” は実装では **CTE + UNION** にすると読みやすい（owner / shares / hierarchy / territory をUNION）

---

## 11. キャッシュ戦略（必須）

### 11.1 Permission Cache（ユーザ単位）

* `EffectivePermissionResolver` の結果をキャッシュ
* 失効：`PermissionChanged` を受けたらユーザ単位で消す（対象userが分からない場合は tenant全消しも可）

### 11.2 ShareModelVersion（テナント単位）

* `share_model_versions.current` をキャッシュ
* `SharingRebuildCompleted` で失効

### 11.3 SubjectSet（ユーザ単位）

* RoleAncestors/GroupSet/TerritorySet は PermissionCache に含める

---

## 12. 受入条件（権限・共有）

1. Object/Field Permissionが **Get/Query/Search/Report** の全経路で一貫
2. RecordAccessが常に適用され、見えないレコードは404
3. Editは「Object Edit」かつ「Record Write」かつ「Field Editable」を満たす場合のみ成功
4. Approval LockがWriteに確実に効く
5. Share再計算（version切替）後に、一覧/検索/レポートの表示が破綻しない（最終関門がCoreにあるため）
