# E5 エッジケース集 v1（運用で揉めないための仕様Q&A）

## 0. 方針（まず結論）

* **Single Writer（Core）** を守る限り、整合の“最終責任”はCoreに集約できる
* 周辺（Sharing/Search/Reporting/Automation）は **遅延・欠落・重複**が起きうる前提で設計し、
  **Coreで最終権限評価・最終明細生成**を行う
* 重要な一貫性は「同期（TX内）」で担保し、他は「最終的整合性」で許容する

---

# 1. 同時更新・競合（Optimistic Lock）

## E5-1: 同じレコードを同時に編集したら？

**仕様**

* Coreは **楽観ロック**を採用
* すべての更新は `recordVersion`（= system_modstamp / row_version）を要求する
* クライアントが古い `recordVersion` で更新 → **409 Conflict** を返す

**API例**

* `PATCH /sobjects/Opportunity/{id}`

  * request: `ifMatchVersion: "2026-01-10T..."`

**レスポンス**

* `409 CONFLICT`
* body: 最新versionと差分（可能なら）

---

## E5-2: バルク更新で一部が競合したら？

**仕様**

* バルク更新は `allOrNothing` モードを持つ

  * v1デフォルト：`allOrNothing=true`（整合性優先）
* 競合が1件でもあれば全体をロールバックし、各レコードの理由を返す

---

# 2. 共有（Sharing）再計算中の整合

## E5-3: Sharing再計算（フルリビルド）中に閲覧したら？

**仕様（ShareModelVersion）**

* Sharingは `share_model_versions.current` を参照して評価する
* フルリビルドは **新しいversionを別領域で構築**し、完成後に `current` を切替える（アトミック）
* 切替直後から新共有が有効

**ユーザ影響**

* 切替瞬間に「見える/見えない」が変わることは仕様（正しい動作）

---

## E5-4: 切替直後、Search/Reportの結果が古い共有を含んだら？

**仕様（安全弁）**

* Search/Reportは候補IDを返すだけ
* **最終明細はCoreがRecordAccessを再評価**して返す
  → 古い候補が混ざっても、Coreで落ちるので漏洩しない

---

## E5-5: 共有再計算要求が連打されたら？

**仕様**

* Sharing Serviceは `rebuild_jobs` を持ち、同一tenantで同時に1ジョブのみ実行
* 新規要求は

  * (A) 既存ジョブに合流（最新に更新）
  * (B) キューに積む（最大N件まで）
* v1推奨：**合流**（最新設定で1回再計算すればよい）

---

# 3. 権限（PermissionChanged）とキャッシュ

## E5-6: 権限変更直後に古い権限でアクセスできることはある？

**仕様**

* Permissionはキャッシュされるため、最大で **TTL（例: 5分）** だけ遅延が起きうる
* ただし `PermissionChanged` イベントを受けたら **即失効**する（ベスト）
* 失効が間に合わないケースを許容するなら、管理者UIで「即時反映」を提供（キャッシュ全消し）

**v1推奨**

* `PermissionChanged` でユーザ単位失効が可能なら必ず実装
* 対象ユーザが特定できない変更は tenant全失効でも可

---

# 4. 承認（Approval）ロック

## E5-7: 承認中に編集したら？

**仕様**

* `ApprovalStateReader` が `isLocked=true` を返す場合：

  * 変更対象が `lockedFields` に含まれる → **422**（FIELD_LOCKED）
  * Delete/OwnerChange → **403**（RECORD_LOCKED）
* 例外：ModifyAllを持つ管理者は設定で回避可能（デフォルトは回避不可）

---

## E5-8: 承認の決定と編集が同時に起きたら？

**仕様**

* 競合は Coreの楽観ロックで収束
* 承認決定イベントにより Coreが“承認状態フィールド”を更新する場合も、CoreがSingle Writerで処理
* 最終的に勝つのは **recordVersionが新しい更新**

---

# 5. 削除（Delete）と波及

## E5-9: 削除は物理削除？論理削除？

**仕様（v1推奨：論理削除）**

* `is_deleted` を持つ（Recycle Bin相当）
* 通常Queryは `is_deleted=false` がデフォルト
* 管理者のみ `includeDeleted=true` を指定可能

---

## E5-10: 親を削除したら子はどうなる？

**仕様（オブジェクトごとに固定）**

* 関係ごとに `relationship_delete_policy` を設定

  * `Restrict`（子があると削除不可）
  * `Cascade`（子も論理削除）
  * `SetNull`（参照外し）
* v1推奨例：

  * Account→Contact：Restrict（誤削除防止）
  * Opportunity→LineItem：Cascade（整合性）
  * Quote→QuoteLineItem：Cascade
  * Order→OrderItem：Cascade

---

## E5-11: 削除後のshares/search/reportは？

**仕様**

* Coreが `RecordDeleted` を発行
* Sharing：share行を無効化（削除 or is_active=false）
* Search：ドキュメント削除
* Reporting：結果キャッシュは“古い”可能性があるが、明細生成はCore再評価で落ちる

---

# 6. 自動化（Validation/Workflow）とエッジ

## E5-12: beforeSave FieldUpdate が同一フィールドで衝突したら？

**仕様**

* v1固定：**lastWriteWins**
* `workflow_conflicts` に記録（監査/デバッグ）

---

## E5-13: FieldUpdateが条件を変えて先頭ルールが真になる（再評価問題）

**仕様**

* v1は **一巡のみ**（fixpoint再走査しない）
* 管理者が `order` を調整して意図通りにする

---

## E5-14: Validation e Workflowの順序は？

**仕様（固定）**

* Validation → beforeSave workflow fieldUpdate
  （理由：Validationは“ユーザ入力”を検証し、workflowは補正として扱う。ここは運用で好みが分かれるが、v1は固定。）

※もし「workflowで補正してからvalidation」したいなら、Validationを2種類に分ける（v2）

---

# 7. 検索（Search）と整合・漏洩

## E5-15: Search結果に見えないIDが混ざるのは仕様？

**仕様**

* 起きうる（遅延・共有切替・キャッシュ）
* **最終的にCore recordsByIds で落ちる**ので漏洩しない

---

## E5-16: 検索に出てくるのに一覧に出ない

**仕様**

* Searchは最終的整合。インデックス更新遅延が原因
* UI上は「検索結果が最新でない可能性」を許容（または更新中表示）
* 重要画面は一覧（Core Query）を正とする

---

# 8. レポート（Report）と整合・漏洩

## E5-17: レポート集計値が実際の一覧と一致しない

**仕様**

* v1は Reporting Serviceが Core Query から明細（可視行）を取得して集計するため、原理的に一致する
* ただし非同期レポートは実行時点のスナップショットなので、実行後にデータが変われば一致しないのは仕様

---

## E5-18: レポート結果の“明細ドリルダウン”は？

**仕様**

* run結果に含まれる `recordIds` を Coreへ渡して `recordsByIds` で明細取得
* “見えない行”は落ちる（権限変更の反映）

---

# 9. イベント（Outbox/At-least-once）と重複

## E5-19: 同じイベントが2回届いたら？

**仕様**

* 受信側は `processed_events` で重複排除
* それでも副作用が出ないよう、各サービスは冪等操作（upsert、キー制約）を実装

---

## E5-20: イベントが欠落したら？

**仕様（v1）**

* Outboxは欠落しない前提（同一TX）
* ただし配信停止等で遅延はあり得る
  → 各サービスは定期的に **再同期ジョブ**を持つ（Reindex/Rebuild）

---

# 10. テナント/マルチリージョン

## E5-21: tenantの隔離はどこで保証？

**仕様**

* すべてのテーブルに `tenant_id`
* すべてのクエリに `tenant_id` を必須条件として付与（ORM/クエリビルダで強制）
* 監査（audit）にも tenant_id を必ず含む

---

# 11. APIの振る舞い（404/403の統一）

## E5-22: 見えないレコードは403？404？

**仕様（固定）**

* **Read不可は404**（存在を漏らさない）
* Write不可は

  * Readも不可なら404
  * Readは可だがWrite不可なら403

---

# 12. 受入条件（エッジケース）

1. 競合は409で検出され、データ破壊が起きない
2. 共有再計算中・直後でも漏洩が起きない（Core最終評価）
3. 承認ロックがWriteに確実に効く
4. 削除の波及がpolicy通りで、shares/search/reportが追随する
5. Search/Reportの遅延があっても最終明細は安全
