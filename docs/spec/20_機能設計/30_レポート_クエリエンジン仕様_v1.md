# E4 Report / Query Engine 仕様 v1

## 0. 目的とスコープ

### 0.1 目的

* Sales Cloud相当の「リスト/クエリ」「レポート（集計・グループ化）」を実現する
* **Object/Field/Record 権限（E2）を必ず適用**し、検索・レポート経由でも情報漏洩しない
* 設計を **SQL実装可能**な形で固定し、後からDWH/OLAPへ逃がせる拡張余地を残す

### 0.2 スコープ（v1）

* **Query Engine（Core）**：Get/List/Query（詳細・一覧）
* **Report Engine（Reporting Service想定）**：レポート定義・実行・結果取得
  ※ただし「最終明細はCoreで再評価」という安全弁は必須

### 0.3 非スコープ（v1でやらない）

* 超複雑なクロスオブジェクト集計（多段ネスト、任意SQL）
* ML予測、複雑な計算列
* 巨大データの完全リアルタイム集計（v2以降DWH）

---

# 1. 役割分担（Core vs Reporting Service）

## 1.1 Core（Query Engine）の責務

* レコード明細/一覧を返す際の **最終権限評価**
* Fieldレベルマスキング（Readableのみ返す）
* List/Queryのフィルタ・ソート・ページング
* “レポートの明細取得”の最終関門 API を提供

### Coreが提供する必須API（内部/外部）

* `POST /v1/query/execute`（汎用クエリ）
* `POST /v1/query/recordsByIds`（ID集合から可視行だけ返す：Search/Reports用安全弁）
* `POST /v1/query/explain`（任意：実行計画/制限理由を返す）

## 1.2 Reporting Service（Report Engine）の責務

* レポート定義（フォルダ/権限）
* 集計実行（同期/非同期）
* 結果キャッシュ（runId）
* “候補ID/集計値”の返却
* 明細が必要な場合は **Coreへ recordsByIds を呼ぶ**（漏洩防止）

---

# 2. クエリモデル（Query DSL v1）

## 2.1 QueryRequest（JSON）

```json
{
  "objectName": "Opportunity",
  "select": ["Id","Name","StageName","Amount","CloseDate","OwnerId"],
  "where": {
    "and": [
      {"field":"IsDeleted","op":"=","value":false},
      {"field":"CloseDate","op":">=","value":"2026-01-01"},
      {"field":"StageName","op":"in","value":["Prospecting","Negotiation"]}
    ]
  },
  "orderBy": [{"field":"CloseDate","direction":"asc"}],
  "limit": 50,
  "offset": 0,
  "includeTotalCount": true
}
```

## 2.2 演算子（v1）

* `=`, `!=`, `>`, `>=`, `<`, `<=`
* `in`, `notIn`
* `contains`（部分一致：実装はLIKE or全文検索に委譲）
* `isNull`, `isNotNull`
* `between`
* `startsWith`, `endsWith`

## 2.3 フィールド参照制約（重要）

* select/where/orderBy に使えるフィールドは **Metadataで許可されたもののみ**
* Field Permission（Readable）に反する select は

  * **返却時にマスク**（推奨：selectから落とす）
* EditableはQueryには関係なし

---

# 3. 行レベル権限適用（E2）をQueryに落とす

## 3.1 方式（v1固定：安全重視）

**方式A：Accessible IDs を先に作ってから本体を取る（推奨）**

### なぜAか

* アクセス条件の組み込み（EXISTS/JOIN）を毎回やると複雑＆バグの温床
* とくにRole/Territory/Team/ManualShare/CriteriaShareが混ざると破綻しやすい

## 3.2 Accessible IDs の生成（共通アルゴリズム）

入力：`tenantId, userContext(SubjectSet), objectName, action(Read/Write), filters(optional)`
出力：`accessible_ids (record_id)` のストリーム（SQLでCTE）

### CTE構成（概念）

`accessible_ids` は以下の UNION で作る（順序は不要）

1. **Owner**：`owner_id = userId`
2. **OWD Public**：OWDがPublicなら `ALL`（WHERE句でショートカット）
3. **Role Hierarchy**（GAUH=trueの場合）：`owner_role in descendants(userRole)` を満たすレコード
4. **Team**：team member によるアクセス
5. **Territory**：territory assignment によるアクセス
6. **Shares**：`object_shares` subject一致で access_level >= required
7. **Implicit**：ControlledByParent は（v1）親アクセスの join を入れる（対象オブジェクトだけ）

> ViewAll/ModifyAll はここをスキップ（全件候補）

## 3.3 クエリ実行の2段階（固定）

* Step1: `ids = accessible_ids WHERE (filters that can be applied safely)`
* Step2: `SELECT fields FROM object_table WHERE id IN (ids) ORDER BY ... LIMIT/OFFSET`

### フィルタの安全な適用

* フィルタは原則 Step2 でかける（安全）
* ただし性能のため、Step1にも「owner_id」「closeDate」など索引が効く条件を一部押し込むことは許可
  → v1では実装を簡単にするため **全フィルタはStep2** を推奨

---

# 4. ページング仕様（v1）

## 4.1 offset/limit（v1採用）

* `offset/limit` を採用（実装容易）
* ただし大規模データで遅くなるため、v2で `cursor-based` を追加

## 4.2 includeTotalCount

* `includeTotalCount=true` の場合のみ `COUNT(*)` を実行

  * ただし `COUNT` もアクセス条件を含む必要あり（ids生成＋count）

---

# 5. レポート仕様（Report DSL v1）

## 5.1 レポートタイプ（v1）

* Tabular（明細一覧）
* Summary（グループ化＋小計）
* Matrix（行×列の2軸グループ）
* Chart（Summary/Matrixの結果を可視化）

## 5.2 ReportDefinition（例）

```json
{
  "reportId":"uuid",
  "name":"Pipeline by Stage",
  "folderId":"uuid",
  "baseObject":"Opportunity",
  "columns":["StageName","OwnerId"],
  "measures":[
    {"field":"Amount","agg":"sum","alias":"SumAmount"},
    {"field":"Id","agg":"count","alias":"CountOpp"}
  ],
  "filters": {
    "and":[
      {"field":"IsDeleted","op":"=","value":false},
      {"field":"CloseDate","op":"between","value":["2026-01-01","2026-03-31"]}
    ]
  },
  "groupBy": {
    "rows":[{"field":"StageName"}],
    "cols":[]
  },
  "sort":[{"by":"SumAmount","direction":"desc"}],
  "detailRows": false,
  "rowLimit": 2000
}
```

### 5.2.1 measures（集計）

* `agg`: `count`, `sum`, `min`, `max`, `avg`
* `countDistinct` は v2（実装コスト高め）

### 5.2.2 groupBy

* rows/cols の最大数：v1は各2まで（運用で制限）

---

# 6. レポートの権限適用（最重要）

## 6.1 レポート定義閲覧権限

* `ReportFolder` に対して Read 権限が必要
* ReportDefinition内のフィールドは **Readableフィールドのみ有効**

  * 読めないフィールドが含まれる場合：

    * v1推奨：レポート保存時に拒否（管理者に明確に伝える）

## 6.2 実行時の行権限（RecordAccess）

* Reporting Serviceは **BaseObjectの候補集合**を作る必要があるが、
* v1ベスト：Reporting Serviceは **Coreへ“候補IDの生成/明細取得”を委譲**する

### 6.2.1 ベスト実装（推奨）

1. Reporting Service → Core `POST /v1/query/execute` を使って

   * 「必要な粒度の明細（Id + groupBy fields + measure fields）」を **可視行だけ** 取得
2. Reporting Service側で groupBy/agg を計算
3. 明細行が必要なら、run結果のID集合を Core `recordsByIds` で取得（再評価は冗長だが安全）

> この方式だとReporting Serviceは shares の複雑さを持たずに済み、漏洩責任をCoreに集約できます。

## 6.3 それでも大量で厳しい場合（v2の逃げ道）

* `accessible_ids` を Sharing DB 側で materialize しておき、Reporting Serviceが直接参照
  → ただし漏洩事故の責任が分散するので v1では避ける

---

# 7. レポート実行方式（同期/非同期）

## 7.1 同期実行（小規模）

* rowLimit <= 20k など閾値以内は同期で返す

## 7.2 非同期実行（標準）

* `POST /v1/reports/{id}/run` → `runId` 返却
* 実行はジョブキュー
* `GET /v1/reports/{id}/results/{runId}` で取得
* 結果は一定期間キャッシュ（例：24h）

---

# 8. 実装詳細（SQLパターン）

## 8.1 Summary Reportの実行（推奨）

* Core Query Engineで「可視行の必要列だけ」を取る

  * columns: groupBy fields + measure fields + Id
* Reporting Serviceでアプリ集計（Map/Group）

  * 20k〜200k程度なら十分現実的

## 8.2 DB集計に寄せる場合（オプション）

* Coreが `accessible_ids` をCTEで作り、
* `SELECT groupBy, SUM(amount) FROM opportunities WHERE id IN (accessible_ids) GROUP BY ...`
* ただし groupBy/measure に使うフィールドは readable を保証し、漏洩しないこと

v1は「実装容易性」を優先し、**アプリ集計を標準**にします。

---

# 9. Searchとの統合（安全弁）

## 9.1 Search結果の扱い

* Search Serviceは `[{objectName, recordId, score}]` を返すのみ
* クライアントに明細を返す時は必ず：

  * Core `recordsByIds(objectName, ids)` を通す（最終権限評価）

## 9.2 recordsByIds API仕様（例）

```json
{
  "objectName":"Opportunity",
  "recordIds":["id1","id2","id3"],
  "select":["Id","Name","StageName","Amount"],
  "preserveOrder": true
}
```

返すのは“見える行だけ”。見えないものは落ちる（404は出さない、集合操作のため）。

---

# 10. 監査・説明可能性（Explain）

## 10.1 Query Explain（任意だが強く推奨）

* 「なぜこの条件が拒否されたか」「なぜ遅いか」を返す
* 例：フィールドがReadableでない、whereに未許可フィールド、limit上限超過等

---

# 11. 制限（ガードレール：v1）

* 1クエリの最大select数：200
* 1クエリの最大where条件：50
* `contains` の濫用は制限（全文検索へ誘導）
* レポートの最大明細行：2,000（Salesforceも近い制限がある）

---

# 12. テスト境界（E4）

## 12.1 Core Query Engine

* 権限適用：見えないレコードが混ざらない
* Field mask：読めないフィールドが返らない
* orderBy/limit/offset の結果安定性
* recordsByIds の安全弁

## 12.2 Reporting Service

* 定義の妥当性（Readable fieldのみ）
* groupBy/agg の正確性
* runIdのキャッシュ・再取得

---

# 13. 受入条件（Query/Reports）

1. 一覧/検索/レポート経由でも、最終的に見える行しか返らない（Core再評価）
2. 読めないフィールドは返らず、レポート定義にも入らない
3. 集計は正しく、権限による除外が反映される
4. 大量時は非同期に逃がせ、結果はrunIdで再取得できる
