# アプリケーションアーキテクチャ設計 v1

## 0. 目的と設計原則

### 目的
* 大規模で複雑なCRMロジック（共有・自動化・監査）を、メンテナンス可能かつスケーラブルな構造で実装するための指針を定める。
* Salesforceのアーキテクチャ（マルチテナント・保存パイプライン）をモダンな技術スタックで再現する。

### 設計原則
* **サービス間疎結合**: 各ドメイン（Accounts, Opportunities等）は独立したサービスとして扱い、境界を越える操作は明確なAPIまたはイベント経由で行う。
* **保存パイプラインの統一**: UI、API、バルク処理のすべてが同一のバリデーション・自動化経路を通ることを保証する。
* **結果整合性の活用**: 共有の再計算や検索インデックスの更新など、重い処理は非同期（Event-driven）で行い、参照時のパフォーマンスを優先する。

---

# 1. サービスモジュール境界

システムを以下の物理・論理モジュールに分割する。

### 1.1 Core SObject Service
* **責務**: CRUD操作、メタデータ管理（Describe）、カスタムフィールド処理。
* **対象**: Accounts, Contacts, Leads, Opportunities 等。
* **保存パイプラインの実行主体**。

### 1.2 Sharing & Security Service
* **責務**: 権限（CRUD/FLS）チェック、レコード共有判定、共有行（ObjectShare）の生成・再計算。
* **アルゴリズム**: ロール階層の展開、グループ展開、共有ルールの評価。

### 1.3 Automation Engine
* **責務**: Validation Rules, Workflow Rules, Scheduled Jobs の評価と実行。
* **特徴**: AST評価器を内包し、定義された条件式に基づき副作用（フィールド更新、通知等）を発生させる。

### 1.4 Approval Service
* **責務**: 承認プロセスの状態遷移管理、作業アイテム（WorkItem）の割当、承認中のレコードロック。

### 1.5 Interface Service
* **責務**: REST API, Bulk API, Reporting API の提供。

---

# 2. トランザクション境界と実行モデル

## 2.1 同期（Synchronous）実行範囲
保存パイプラインのうち、ユーザへの即時応答（またはロールバック）が必要な範囲。

1. **Transaction Start**
2. **AuthZ Gate**: 操作権限の確認。
3. **Before Save Automation**: 同期的なフィールド補完。
4. **Validation Rules**: 入力制約チェック（失敗ならAbort）。
5. **DB Persist**: レコードの保存。
6. **After Save (Sync) Automation**: 同期的な集計（親レコードの金額合計など）。
7. **Transaction Commit**

## 2.2 非同期（Asynchronous / Event-driven）実行範囲
コミット後、バックグラウンドで行う処理。

* **Sharing Recalculation**: Owner変更やルール変更に伴う共有行の再計算。
* **Async Workflow**: 通知（メール/Push）、Webhook呼び出し、外部連携。
* **Search Indexing**: 全文検索（OpenSearch等）への反映。
* **Audit Finalization**: 重い監査ログの永続化。

---

# 3. イベント設計（Sharing & Search）

変更イベントをメッセージバス（RabbitMQ, Kafka, または Postgres LISTEN/NOTIFY）経由で配信する。

| Event Type | Source | Consumers | Payload |
| :--- | :--- | :--- | :--- |
| `RECORD_CHANGED` | SObject Service | Sharing, Search, Workflow | `tenantId, objectName, recordId, changedFields, oldValues` |
| `OWNER_CHANGED` | SObject Service | Sharing Service | `tenantId, recordId, oldOwnerId, newOwnerId` |
| `ROLE_CHANGED` | Metadata Service | Sharing Service (Recalculate) | `tenantId, roleId, parentChanged` |
| `SHARE_RECALC_REQ` | Sharing Service | Sharing Worker | `tenantId, objectName, scope(Record/Full)` |

---

# 4. 共有判定の最適化（Physical Access Control）

## 4.1 権限展開情報のキャッシュ（Permission Snapshot）
ユーザがログインしたタイミング、または所属（Role/Group/Territory）が変更されたタイミングで、そのユーザが持つ「すべてのSubjectId（自分、自分のプロファイル、所属する全グループ、全ロール）」をフラットな配列としてキャッシュする。

* **Key**: `perm_snapshot:{tenantId}:{userId}`
* **Value**: `[userId, profileId, roleId, group1Id, group2Id, ...]`

## 4.2 クエリへの適用
このキャッシュされたIDリストを、DB検索の `IN` 句または `EXISTS` 句に渡すことで、複雑な再帰計算をSQL実行時に回避する（物理DB設計の 2.1 参照）。

---

# 5. ステート管理（Record Locking）

## 5.1 楽観的ロック（Optimistic Locking）
* `system_modstamp` を使用し、更新時に `WHERE system_modstamp = :val` を指定。競合時は 409 Conflict を返す。

## 5.2 承認中ロック（Approval Locking）
* `IsLocked` フラグ（または論理的な状態判定）により、承認中のレコード編集を SObject Service レベルで拒否する。

---

# 6. 受入条件（アーキテクチャ）

1. 保存パイプラインが全ての入口（UI/API/Bulk）で統一されていること。
2. 重い共有再計算によって、メインのCRUDレスポンスが劣化しないこと（非同期化）。
3. キャッシュ（Permission Snapshot）の無効化（Invalidation）が、所属変更時に正しく行われること。
4. 循環参照や無限ループ（Workflow）が、最大実行深度（Depth Limit）によって防止されていること。
