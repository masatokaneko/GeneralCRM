# 権限・共有（Authorization / Sharing）詳細仕様書 v1

## 0. 目的とスコープ

本書は以下を定義する：

*   **認証後**に、ユーザが
    *   どのオブジェクトに対して（Object）
    *   どの項目を（Field）
    *   どのレコードに対して（Record）
    *   どの操作をできるか（Action）
    を **一貫して** 判断する仕組み
*   一覧・詳細・検索・レポート・API・エクスポート・イベント配信等で **同じ結果** になること（INV-SH1）

### 対象
*   Object Permission（CRUD + 特権）
*   Field Permission（参照/編集）
*   Record Sharing（OWD/ロール階層/共有ルール/手動共有/チーム/テリトリ）
*   共有行（ObjectShare）の生成と再計算
*   検索/レポートへの適用

---

# 1. 権限の全体アーキテクチャ（3層モデル）

## 1.1 三層（必須）

1.  **Object Permission**: そのオブジェクト自体を操作できるか（例：OpportunityをEditできるか）
2.  **Field Permission**: その項目を参照/編集できるか（例：Opportunity.Amount を閲覧できるか）
3.  **Record Sharing**: そのレコードにアクセスできるか（例：商談Aを見れるか）

> 結果は `FinalAccess = ObjectPerm ∩ FieldPerm ∩ RecordAccess`

---

# 2. 権限要素（データモデル）

## 2.1 主体（Subject）

*   User
*   Role（階層あり）
*   Group（Public Group / Queue）
*   Territory（階層あり）
*   Team（AccountTeam/OpportunityTeam 由来の擬似主体でも可）

Subjectは最終的に「ユーザ集合」に展開できなければならない。

---

## 2.2 付与要素（Permission Assignment）

### 2.2.1 PermissionProfile（基本ロール）
*   ユーザに必ず 1 つ紐付く「基本権限セット」（例：AE、Manager、Marketing、Admin）。

### 2.2.2 PermissionSet（追加）
*   権限を加算するための集合。複数付与可能。

### 2.2.3 System Permission（特権）
以下はSalesforce同等の実用上必須なので、**明示的に定義**する：
*   `ViewAll(Object)`: そのオブジェクトの全レコードを閲覧可（共有無視）
*   `ModifyAll(Object)`: そのオブジェクトの全レコードを編集/削除可（共有無視）
*   `ViewSetup` / `ModifySetup`: 設定（メタデータ）閲覧/変更
*   `ViewAudit`: 監査ログ閲覧
*   `TransferRecord(Object)`: 所有者変更権限
*   `ManageSharing(Object)`: 手動共有の追加/削除権限
*   `ManageTerritory`: テリトリモデル操作権限

---

## 2.3 オブジェクト権限（Object Permission）
各オブジェクトごとに以下を持つ：
*   Create / Read / Update / Delete (CRUD)
*   （任意）Undelete, Merge, Convert, Export, MassUpdate など

---

## 2.4 項目権限（Field Permission）
各フィールドごとに以下：
*   Readable（参照可）
*   Editable（編集可）

ルール：
*   Editable => Readable（編集できるなら読める）
*   機微情報（例：個人情報、金額、原価、競合、調整値など）はField Permissionで制御する。

---

# 3. レコード共有（Record Sharing）の仕様

## 3.1 AccessLevel（レコード権限レベル）
最低限この 2 段階は必須：
*   **Read**: 閲覧のみ
*   **Write**: 編集可能（Update可能）

Delete/Transfer は **オブジェクト権限＋特権** で追加判定する（シンプルにするため）。

---

## 3.2 OWD（Organization-Wide Default）
オブジェクトごとに `OWDSetting.DefaultAccess` を持つ：
*   **Private**: 所有者以外は見えない。共有で付与する。
*   **PublicReadOnly**: 全員が見れるが、編集は所有者 or 共有付与者。
*   **PublicReadWrite**: 全員が見れるし、全員が編集できる。

---

## 3.3 共有のソース（RowCause）
共有行（ObjectShare）の由来を必ず記録する：
*   **Owner**（所有者）
*   **RoleHierarchy**（ロール階層）
*   **Rule**（共有ルール）
*   **Manual**（手動共有）
*   **Team**（チーム）
*   **Territory**（テリトリ）
*   **Implicit**（暗黙共有：親子関係由来）

---

## 3.4 共有評価の“原則”
*   **共有は加算**（権限は“足し算”で増える）。減衰は通常なく、OWDや設定変更で再計算して表現する。
*   例外は `ModifyAll/Object` などの特権（共有を無視する）。

---

# 4. RecordAccessの評価アルゴリズム（実装仕様）

## 4.1 前提：ユーザのEffective Permissionの計算
ログイン時、またはキャッシュ時に以下を計算し保持する：
*   `EffectiveObjectPerms[Object]`
*   `EffectiveSystemPerms`
*   `EffectiveFieldPerms[Object.Field]`
*   `UserRolePath`: 自分のRoleと上位Roleの全リスト
*   `UserGroups`: 所属するPublic Group/QueueのID集合
*   `UserTerritories`: 割当Territoryの集合＋上位Territoryのパス

---

## 4.2 レコードアクセス判定（関数仕様）

### 関数
`getRecordAccess(userId, objectName, recordId) -> AccessLevel | None`

### 判定手順（順序が重要）

1.  **System override（最優先）**
    *   `ModifyAll(object)` 特権があれば `Write`
    *   `ViewAll(object)` 特権があれば `Read`（ただし Write 権限が別途あれば Write）
2.  **Object Read が無ければ即 None**
3.  **OWDがPublicの場合**
    *   PublicReadWrite なら、個別の共有計算をスキップして `Write` と判定してもよい
    *   PublicReadOnly なら、`Read` は成立、`Write` は共有または特権で上げる
4.  **Owner**
    *   `record.OwnerId == userId` なら `Write`
5.  **Role hierarchy**
    *   `record.OwnerRole` が `userRolePath` の下位にある場合、規定レベル（通常 Write か ReadOnly を設定で選択）でアクセス。
6.  **Implicit share（親子暗黙共有）**
    *   Contact: Accountにアクセスがあれば、最低 Read でアクセス可。
    *   Opportunity: Accountにアクセスがあれば、最低 Read でアクセス可。
    *   明細項目: ヘッダ（Opp等）にアクセスがあれば、完全に同期したアクセス（Read/Write）を許可。
7.  **ObjectShare（共有行）の評価**
    *   `ObjectShare` テーブルを検索し、以下に一致するレコードをすべて集計する：
        *   `SubjectType = User` & `SubjectId = userId`
        *   `SubjectType = Role` & `SubjectId ∈ userRolePath`
        *   `SubjectType = Group` & `SubjectId ∈ userGroups`
        *   `SubjectType = Territory` & `SubjectId ∈ userTerritories`
8.  **最大アクセスレベルの採用**
    *   上記で見つかったアクセス権（Read/Write）のうち、最も高いものを採用する。

---

# 5. 共有行（ObjectShare）の生成ルール

## 5.1 生成対象（最低限Must）
*   `AccountShare`
*   `OpportunityShare`
*   `LeadShare`
*   `QuoteShare` / `OrderShare`
*   `ActivityShare` (Task/Event)
*   `ContentDocumentLink` / `ContentShare` (添付)

---

## 5.2 RowCause別の生成
*   **(A) Owner**: レコード作成/所有者変更時に自動生成。旧所有者のOwner行は削除。
*   **(B) RoleHierarchy**: 所有者の上位ロール全員に共有行を生成（または評価時に動的解決。性能と一貫性のトレードオフ）。
*   **(C) Rule（共有ルール）**: バッチまたは非同期処理で、条件に合致するレコードと対象Subjectの紐付けを生成。
*   **(D) Manual（手動共有）**: UI/APIから明示的に作成。
*   **(E) Team**: Account/Opportunity Team メンバ追加時に、定義されたアクセスレベルで生成。
*   **(F) Territory**: Account割当時に、そのTerritoryに属するユーザ/ロールへ共有を生成。

---

# 6. 共有の再計算（Rebuild / Incremental）

## 6.1 再計算が必要なトリガ
1.  **OWD変更**: 最も重い。全レコードの共有を再評価。
2.  **共有ルール変更**: そのルールの対象レコード・Subjectのみ再計算。
3.  **ロール階層/グループ構成/テリトリ割当の変更**: 影響を受けるユーザ集合の共有を再計算。
4.  **レコード所有者変更**: 所有者、ロール、チーム、テリトリ、暗黙共有がすべて変わるため、即時または非同期で再計算。

## 6.2 再計算の方式
*   **Incremental（差分）**: トランザクションまたはキューイングで逐次処理。
*   **Full Rebuild（全再構築）**: RowCause別に、全レコードの共有行を生成し直す。
*   **一貫性保証**: 再計算中は「古い権限」を保持し、新旧のスイッチをアトミックに行う（INV-SH2）。

---

# 7. 検索・一覧・レポート・APIへの適用

## 7.1 クエリ実行時の適用ルール（INV-SH1）
1.  **フィルタの自動追加**: クエリ生成時に、`RecordAccess >= Read` を満たす条件を暗黙的に追加する。
    *   SQL例: `SELECT * FROM Opportunity o WHERE EXISTS (SELECT 1 FROM OpportunityShare os WHERE os.RecordId = o.Id AND os.SubjectId IN (...))`
2.  **FLSによるフィルタアウト**: `Field Readable = false` である項目は、APIレスポンスから削除し、`SELECT` 句からも除外する。
3.  **ソート・検索条件の制限**: 参照できないフィールド、またはアクセス権のないレコードを検索キーとした「ブラインド検索」を防止する。

---

# 10. 操作別の最終判定（まとめ）

*   **Read (閲覧)**: Object Read ∩ Record Read
*   **Create (作成)**: Object Create ∩ (Parent Access if required)
*   **Update (更新)**: Object Update ∩ Record Write ∩ (All edited fields are Editable)
*   **Delete (削除)**: Object Delete ∩ Record Write (or Owner or 특権)
*   **Transfer (所有者変更)**: `TransferRecord(Object)` 特権 ∩ Record Write
*   **Share (手動共有)**: `ManageSharing(Object)` 特権 ∩ Record Write

---

# 11. テスト仕様（ケース）

*   [ ] OWD=Private で他人のレコードが見えないこと。
*   [ ] 共有ルールで想定通りアクセス権が拡張されること。
*   [ ] ロール hierarchy の上位者が下位者のレコードを編集できること。
*   [ ] `ViewAll` 特権ですべてのレコードが一覧に現れること。
*   [ ] `Field Readable = false` の項目が API レスポンスに含まれないこと。
*   [ ] 非同期での共有再計算中も、アクセス権が極端に不安定にならないこと。
*   [ ] レポートで集計される数値が、手元で見れるレコードの合計と一致すること。
